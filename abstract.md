# Конспект
## Оглавление

1. [Классифиĸация атрибутов ĸачества](#классифиĸация-атрибутов-ĸачества)
2. [Анализ ĸомпромиссов (Trade-Off анализ)](#анализ-компромиссов-trade-off-анализ)

<a name="классифиĸация-атрибутов-ĸачества"></a>

# Классифиĸация атрибутов ĸачества

Любое приложение или программное обеспечение состоит из функциональных требований. Это совокупность функций, которые должна выпонять наш программный продукт. Но при этом есть ряд характеристик, которые не относятся к функциональным требованиям. Например, весь код проекта может находиться в одном месте, а может быть разделён на множество модулей. Или проект может по-разному раегировать на увеличиващуюся нагрузку. Если смотреть со стороны, то на первый взгляд эти проекты будут одинаково выполнять функциональные требования. Но если он не будет соответствовать нефункциональным требованиям, таким как безопасность или масштабируемость, то могут возникнуть проблемы как с законом, так и с лояльностью пользователей.
Есть следующие основные нефункциональные требования: <br>
1. Maintainability - поддерживаемость. Насколько эффективно мы можем вносить изменения в текущий продукт и поддерживать его
2. Security - безопасность. Насколько эффеткивно система защищает данные, допускает к ним пользователий только при наличии доступа, отслеживает объект сделавший несанкционированное проникновение
3. Relyability - надежность. Насколько хорошо система продолжает работать при различных сбоях и непредвитденных обстоятельствах
4. Scalability - масштаблируемость. Насколько хорошо система спарляется с нагрузками
5. Testability - тестируемость. Насколько удобно система позволяет тестировать текущее состояние или изменения.
6. Overall cost - итоговая стоимость. Стоимость разработки и поддержки сервиса.

И некоторые другие артибуты.  
Есть специальные стандарты ISO которые описывают требования, которым должен сответстовавать программный продукт или программное обеспечение.

<a name="анализ-компромиссов-trade-off-анализ"></a>

# Анализ ĸомпромиссов (Trade-Off анализ)

При принятии архитектурной моделине существует идеального решения. Обычный программист видит одни преимущества в любых технлогиях и не видет компромиссов. Архитектор же умеет анализировать несколько вариантов решения и выбрать наиболее подходящий при рахных обстоятельствах. Например, если у нас есть сервис "A" который пишет события в топик, и этот топик читают несолько других сервисов. Или же можно сделать для каждого сервиса очереди, куда будет писать наш сервис "A". В первом варианте перед вторым будут следующие преимущества - слабая связность и легкая архитектурная машстабируемость. Но будут недостатки в виде безопасности подключения к топику и единый контракт для всех сервисов.

# Архитеĸтурные шаблоны

Архитектурный шаблон - это уже существующее решение для повторяющихся артихектурных проблем. С помощью языка шаблонов архитекторы могут общаться с разработчиками. Например, когда мы говорим про микросервисы или монолит.  
Шаблоны высшего порядка или архитектурные стили имеют огромное влияние на архитектуру приложения и показатели качества системы. Каждый архитектурный стиль имееют свои достоинства и компромиссы, и архитектор должен уметь в них разбираться чтобы подобрать наиболее подходящий. Архитектурные стили нужны для того, чтобы уменьшить энтропию программного обеспечения и добавить модульность, чтобы уменьшить связанность Разберём компромиссы.  
1. Модульность - свойство системы, связанное с её возможностью на декомпозицию на ряд внутренне связанных между собой модулей. Чем лучше модульность, тем меньше изменения одного модуля влияют на другой модуль.
2. Распределённость. Распределённые системы состоят из нескольких узлов, работающих вместе как одно целое для достижения общей цели. Распределённость не даётся бесплатно
    1. Сеть не надёжна
    2. Ведение журналирование
    3. Реализовать трассировку вызовов
    4. Осуществить распределённую тразнацию
    5. Поддержка контрактов и управление версиями

## Модульность

Модульность является мерой того, насколько дешёво нам обходятся изменения в проекте. Чем сильнее изменения влияют на программный код, тем он обладает большей связанностью. Разделив проект на модули мы хотим уменьшить связанность и менять модули независимо друг от друга.

### Оси измерения связанности
Компоненты внутри одной системы должны иметь какую-либо связь, чтобы вместе они могли выполнять функциональные требования и связи нужны нам для достижения общей цели.  
Есть три оси измерения, по которым можно определить насколько компоненты связаны между собой.

1. Сила
2. Расстояние
3. Валотильность (изменичвость)

#### 1. Сила
Есть 4 уровня силы связаности:
1. Навязчивая связанность.  
Таĸой уровень связи связывает ĸомпоненты на уровне деталей реализации или приватных интерфейсов
2. Фунĸциональная связанность  
Означает, что связанные ĸомпоненты реализуют тесно связанные бизнес фунĸции. Другими словами, одно и тоже бизнес требование затронет изменения связанных ĸомпонентов.
3. Связанность бизнес моделей.  
Означает что ĸомпоненты используют одну и ту же модель бизнес области. Используются ограниченные контексты.
4. Контраĸтная связанность.  
Интеграция при помощи контрактов строго отделена от деталей реализации.

#### 2. Расстояние
Расстояние обозначает сколько уровней абстракции разделют два модуля между собой. Например, изменения могут быть в одной функции, у них расстояние будет наименьшим. А если модули находятся в разных сервисах, то расстояние будет большим. Чем больше расстояние тем больше стоимость изменений.

#### 3. Валотильность (изменчивость)
Совместная изменчивость компонент. Валотильность характеризует то, насколько часто два компонента часто меняются вместе.

### Coupling
Coupling - это мера того, насĸольĸо сильно связанны два ĸомпонента. Связанность = Сила * Расстояние * Валотильность.  
Loose coupling = низĸая сила * большое расстояние * низĸая совместная волатильность.

### Cohesion
Эта мера того насĸольĸо ĸомпоненты фунĸционально связанны. Считается, что cohesion должен быть высоĸим.  
High cohesion = большая сила * маленьĸое расстояние * высоĸая совместная волатильность.