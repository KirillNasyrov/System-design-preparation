# Конспект
## Оглавление

[Классифиĸация атрибутов ĸачества](#классифиĸация-атрибутов-ĸачества)

[Анализ ĸомпромиссов (Trade-Off анализ)](#анализ-компромиссов-trade-off-анализ)

<a name="классифиĸация-атрибутов-ĸачества"></a>

# Классифиĸация атрибутов ĸачества

Любое приложение или программное обеспечение состоит из функциональных требований. Это совокупность функций, которые должна выпонять наш программный продукт. Но при этом есть ряд характеристик, которые не относятся к функциональным требованиям. Например, весь код проекта может находиться в одном месте, а может быть разделён на множество модулей. Или проект может по-разному раегировать на увеличиващуюся нагрузку. Если смотреть со стороны, то на первый взгляд эти проекты будут одинаково выполнять функциональные требования. Но если он не будет соответствовать нефункциональным требованиям, таким как безопасность или масштабируемость, то могут возникнуть проблемы как с законом, так и с лояльностью пользователей.
Есть следующие основные нефункциональные требования: <br>
1. Maintainability - поддерживаемость. Насколько эффективно мы можем вносить изменения в текущий продукт и поддерживать его
2. Security - безопасность. Насколько эффеткивно система защищает данные, допускает к ним пользователий только при наличии доступа, отслеживает объект сделавший несанкционированное проникновение
3. Relyability - надежность. Насколько хорошо система продолжает работать при различных сбоях и непредвитденных обстоятельствах
4. Scalability - масштаблируемость. Насколько хорошо система спарляется с нагрузками
5. Testability - тестируемость. Насколько удобно система позволяет тестировать текущее состояние или изменения.
6. Overall cost - итоговая стоимость. Стоимость разработки и поддержки сервиса.

И некоторые другие артибуты.

Есть специальные стандарты ISO которые описывают требования, которым должен сответстовавать программный продукт или программное обеспечение.

<a name="анализ-компромиссов-trade-off-анализ"></a>

# Анализ ĸомпромиссов (Trade-Off анализ)

При принятии архитектурной моделине существует идеального решения. Обычный программист видит одни преимущества в любых технлогиях и не видет компромиссов. Архитектор же умеет анализировать несколько вариантов решения и выбрать наиболее подходящий при рахных обстоятельствах. Например, если у нас есть сервис "A" который пишет события в топик, и этот топик читают несолько других сервисов. Или же можно сделать для каждого сервиса очереди, куда будет писать наш сервис "A". В первом варианте перед вторым будут следующие преимущества - слабая связность и легкая архитектурная машстабируемость. Но будут недостатки в виде безопасности подключения к топику и единый контракт для всех сервисов.
 