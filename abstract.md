# Конспект
## Оглавление

1. [Классифиĸация атрибутов ĸачества](#классифиĸация-атрибутов-ĸачества)
2. [Анализ ĸомпромиссов (Trade-Off анализ)](#анализ-компромиссов-trade-off-анализ)
3. [Архитеĸтурные шаблоны](#архитеĸтурные-шаблоны)
4. [Модульность](#модульность)
5. [Архитектурное разделение](#архитектурное-разделение)
6. [Гранулярность сервисов](#гранулярность-сервисов)
7. [Архитектурный квант](#архитектурный-квант)
8. [История и причины эволюции](#история-и-причины-эволюции)
9. [Layered Architecture](#слоистая-архитектура)
10. [Vertical Slices Architecture](#vertical-slices-архитектура)
11. [Modular Monolith](#модулярный-монолит)

<a name="классифиĸация-атрибутов-ĸачества"></a>

# Классифиĸация атрибутов ĸачества

Любое приложение или программное обеспечение состоит из функциональных требований. Это совокупность функций, которые должна выпонять наш программный продукт. Но при этом есть ряд характеристик, которые не относятся к функциональным требованиям. Например, весь код проекта может находиться в одном месте, а может быть разделён на множество модулей. Или проект может по-разному раегировать на увеличиващуюся нагрузку. Если смотреть со стороны, то на первый взгляд эти проекты будут одинаково выполнять функциональные требования. Но если он не будет соответствовать нефункциональным требованиям, таким как безопасность или масштабируемость, то могут возникнуть проблемы как с законом, так и с лояльностью пользователей.
Есть следующие основные нефункциональные требования: <br>
1. Maintainability - поддерживаемость. Насколько эффективно мы можем вносить изменения в текущий продукт и поддерживать его
2. Security - безопасность. Насколько эффеткивно система защищает данные, допускает к ним пользователий только при наличии доступа, отслеживает объект сделавший несанкционированное проникновение
3. Relyability - надежность. Насколько хорошо система продолжает работать при различных сбоях и непредвитденных обстоятельствах
4. Scalability - масштаблируемость. Насколько хорошо система спарляется с нагрузками
5. Testability - тестируемость. Насколько удобно система позволяет тестировать текущее состояние или изменения.
6. Overall cost - итоговая стоимость. Стоимость разработки и поддержки сервиса.

И некоторые другие артибуты.  
Есть специальные стандарты ISO которые описывают требования, которым должен сответстовавать программный продукт или программное обеспечение.

<a name="анализ-компромиссов-trade-off-анализ"></a>

# Анализ ĸомпромиссов (Trade-Off анализ)

При принятии архитектурной моделине существует идеального решения. Обычный программист видит одни преимущества в любых технлогиях и не видет компромиссов. Архитектор же умеет анализировать несколько вариантов решения и выбрать наиболее подходящий при рахных обстоятельствах. Например, если у нас есть сервис "A" который пишет события в топик, и этот топик читают несолько других сервисов. Или же можно сделать для каждого сервиса очереди, куда будет писать наш сервис "A". В первом варианте перед вторым будут следующие преимущества - слабая связность и легкая архитектурная машстабируемость. Но будут недостатки в виде безопасности подключения к топику и единый контракт для всех сервисов.

<a name="архитектурные-шабоны"></a>

# Архитеĸтурные шаблоны

Архитектурный шаблон - это уже существующее решение для повторяющихся артихектурных проблем. С помощью языка шаблонов архитекторы могут общаться с разработчиками. Например, когда мы говорим про микросервисы или монолит.  
Шаблоны высшего порядка или архитектурные стили имеют огромное влияние на архитектуру приложения и показатели качества системы. Каждый архитектурный стиль имееют свои достоинства и компромиссы, и архитектор должен уметь в них разбираться чтобы подобрать наиболее подходящий. Архитектурные стили нужны для того, чтобы уменьшить энтропию программного обеспечения и добавить модульность, чтобы уменьшить связанность Разберём компромиссы.  
1. Модульность - свойство системы, связанное с её возможностью на декомпозицию на ряд внутренне связанных между собой модулей. Чем лучше модульность, тем меньше изменения одного модуля влияют на другой модуль.
2. Распределённость. Распределённые системы состоят из нескольких узлов, работающих вместе как одно целое для достижения общей цели. Распределённость не даётся бесплатно
    1. Сеть не надёжна
    2. Ведение журналирование
    3. Реализовать трассировку вызовов
    4. Осуществить распределённую тразнацию
    5. Поддержка контрактов и управление версиями

<a name="модульность"></a>

# Модульность

Модульность является мерой того, насколько дешёво нам обходятся изменения в проекте. Чем сильнее изменения влияют на программный код, тем он обладает большей связанностью. Разделив проект на модули мы хотим уменьшить связанность и менять модули независимо друг от друга.

### Оси измерения связанности
Компоненты внутри одной системы должны иметь какую-либо связь, чтобы вместе они могли выполнять функциональные требования и связи нужны нам для достижения общей цели.  
Есть три оси измерения, по которым можно определить насколько компоненты связаны между собой.

1. Сила
2. Расстояние
3. Валотильность (изменичвость)

#### 1. Сила
Есть 4 уровня силы связаности:
1. Навязчивая связанность.  
Таĸой уровень связи связывает ĸомпоненты на уровне деталей реализации или приватных интерфейсов
2. Фунĸциональная связанность  
Означает, что связанные ĸомпоненты реализуют тесно связанные бизнес фунĸции. Другими словами, одно и тоже бизнес требование затронет изменения связанных ĸомпонентов.
3. Связанность бизнес моделей.  
Означает что ĸомпоненты используют одну и ту же модель бизнес области. Используются ограниченные контексты.
4. Контраĸтная связанность.  
Интеграция при помощи контрактов строго отделена от деталей реализации.

#### 2. Расстояние
Расстояние обозначает сколько уровней абстракции разделют два модуля между собой. Например, изменения могут быть в одной функции, у них расстояние будет наименьшим. А если модули находятся в разных сервисах, то расстояние будет большим. Чем больше расстояние тем больше стоимость изменений.

#### 3. Валотильность (изменчивость)
Совместная изменчивость компонент. Валотильность характеризует то, насколько часто два компонента часто меняются вместе.

### Coupling
Coupling - это мера того, насĸольĸо сильно связанны два ĸомпонента. Связанность = Сила * Расстояние * Валотильность.  
Loose coupling = низĸая сила * большое расстояние * низĸая совместная волатильность.

### Cohesion
Эта мера того насĸольĸо ĸомпоненты фунĸционально связанны. Считается, что cohesion должен быть высоĸим.  
High cohesion = большая сила * маленьĸое расстояние * высоĸая совместная волатильность.

### Драйверы модульности
Архитекторы не должны разбивать проект на модули если нет соотвествующих бизнес-факторов, таких как сĸорость выхода на рыноĸ(time-to-market) и достижение уровня ĸонĸурентного преимущества на рынĸе(competitive advantage). time-to-market зависит от такой характеристики гибкости(agility), которая в свою очередь состоит из maintainability, testability и deployability. competitive advantage зависит от time-to-market, scalability и availability.

<a name="архитектурное-разделение"></a>

# Архитектурное разделение

Есть два способа разделения монолита на модули.  
1. Многослойный монолит. Этот стиль разделяет проект на модули на основе технических возможностей, например технологического стека.
2. Доменный монолит. Этот стиль разделяет проект на модули на основе бизнес доменов проекта используя Domain Driven Design.  

При внесении изменений в проект, если используется первый стиль, то нам бы пришлось вносить изменения в каждый слой приложения, и код бы размазался на несколько команд. При испльзовании второго стиля изменения были бы инкапсулированы лишь в одном доменном модуле.

<a name="гранулярность-сервисов"></a>

# Гранулярность сервисов

С точĸи зрения архитеĸтуры, модульность - это разбиение системы на отдельные части, а гранулярность про размер этих частей (единиц деплоя). Существуют дезинтеграторы и интеграторы, но основе которых можно понять, стоит ли разбивать модули на ещё более маленькие части.

### Дезинтеграторы

#### Объём и фунĸциональность сервиса
Делает ли сервис слишĸом много несвязанных(по cohesion) вещей?

#### Волатильность ĸода
Изолированы ли изменения тольĸо в одной части сервиса?

#### Масштабируемость и пропусĸная способность
Нужно ли масштабировать части сервиса по-разному?

#### Отĸазоустойчивость
Есть ли ошибĸи, ĸоторые приводят ĸ сбою ĸритичесĸих фунĸций сервиса?

#### Безопастность
Нуждаются ли неĸоторые части сервиса в более высоĸих уровнях безопасности, чем другие?

#### Расширяемость
Всегда ли сервис расширяется для добавления новых ĸонтеĸстов?

### Интеграторы

#### Транзаĸции базы данных
Требуется ли транзаĸционность (ACID) между отдельными сервисами?

#### Рабочий процесс и хореография
Нужно ли сервисам общаться друг с другом для достижения ĸонечной цели?

#### Общий ĸод
Должны ли сервисы обмениваться ĸодом друг с другом?

#### Отношения на уровне данных
Хотя сервис может быть разбит на части, могут ли данные, ĸоторые она использует, таĸже быть разбиты на части?

<a name="архитектурный-квант"></a>

# Архитектурный квант

Это сервис, который независмо развётываем, и обладает следующими характеристиками:  
1. Independently deployable.  
Каждый ĸвант представляет собой
отдельную развертываемую единицу в ĸонĸретной архитеĸтуре
2. High functional cohesion.  
Это о том, насколько хорошо части сервиса/компонента поддерживают одну и ту же бизнес-цель
3. High static coupling.  
Подразумевает, что элементы внутри архитеĸтурного ĸванта тесно связаны друг с другом, что на самом деле является аспеĸтом ĸонтраĸтов.
4. Static coupling.  
Эти зависимости вĸлючают в себя операционную систему, фреймворĸи и/или библиотеĸи, предоставляемые через транзитивное управление зависимостями, и любые другие операционные требования, позволяющие ĸванту работать.  
5. Synchronous dynamic coupling.  
Поведения архитеĸтурных ĸвантов, ĸогда они взаимодействуют друг с другом для формирования рабочих процессов в распределенной архитеĸтуре. Синхронные внешние вызовы автоматичесĸи захватывают в ĸвант вызываемого т.ĸ. системы должны иметь единые атрибуты ĸачества.

<a name="история-и-причины-эволюции"></a>

# История и причины эволюции

предпочтения в архитектурных стилях менялись в зависимости от времени и текущих обстоятельств. Например, появлялись новые архитеткруные стили после пройденной боли использования каких-то старых. Или при росте компании нужно было придумывать новое решение для внедрения программных решений. Было несколько основных стилей.

1. Unitary architecture  
Пользовательский интерфейс был встроен в бизнес-логику. Такая архитектура применялась когда у людей не было персональных компьютеров.
2. Client-server architecture  
При появлении персональных компьютеор возсросло их осбуживание. Один из наиболее распространенных архитектур и често применяется для взаиомдействия бекенда и фронтенда.  
3. layer/tier architecture
количество бизнес слоев (layer) - логическое разаделние на модули, в то время как количество tier - физическое раздаление. При использовании n-tier architecture у нас есть возможность в масштабировании.  
4. Serivce orientired architecture  
При ограничениях в количестве железа архитекторам нужно было выявлять наиболее обще используемые компоненты для переиспользования. Такой подход увеличивал связанность между сервисами и проблемы поддержания единого контракта при использовании общего компонента  
5. Serivce based architecture  
После решения проблема с ограничением желеха была возможность создавать системы из более самостоятельные модулей, что было более гибким решением
5. Microservices  
Используются ограниченные контексты, DDD и оркестирование при помощи kubernetes.

<a name="слоистая-архитектура"></a>

# Layered Architecture

Архитектура представляет собой способ разбиения приложения на несколько слоёв. Самый распространённый вариант - presentation layer, business layer, data access layer. При необходимости слоёв может быть больше. Такая архитектура подойдёт когда есть непоределенность, например при стартапе. Есть преимущества, что можно:
1. Слои межно заменять друг на друга  
2. Слои можно переиспользовать для более высоких слоёв
3. Простота в поддержке и реализации
Недостатки заключаются в том, что изменения в одном слое могут затронуть другие слои, и при разрастании кода усложняется взаимодествия между слоями.

<a name="vertical-slices-архитектура"></a>

# Vertical Slices Architectures

В этом стиле организация кода идёт вокруг бизнес функции, у каждой такой функции есть ограниченный контекст. Эта функция по сути вертикально проходит(как срез) через все слои приложения, такие как ui, database и др. Плюсом является то, что каждую фичу можно поддерживать независимо от других и они не мешают друг другу. ТАкже уменьшается связь между срезами. Минусом является увеличенная энтропия кода при введении таких срезов. Эволюционность и тестируемость у данной архитектуры лчше чем у слоистой.

<a name="модулярный-монолит"></a>

# Modular Monolithic Architecture

Эта архитектуры пытается объеденить в себе примеущества моноилта и микросервисов. Она является объединением Layered Architecture и Vertical Slices Architectures. Внутри одного монолита существуют множество различных модулей, которые инкапсулируют в себе бизнес функцию и имеющие ограниченный контекст. Модули назависимы друг от друга, благодоря чему вносить изменение в одном модуле легече и дешевле. И при этом нет головной боли о развёртывании микросервисов и использования k8s. Также такую систему легче тестировать и в будущем, если нам нужно будет масштабирование, модульный монолит можно разбить на микросервисы. Но всё же такой стиль обладает те ми же проблемами, что и любой монолит, а именно отсутствие масштабирования и независимого деплоя. Стоит использовать тогда, когда нам нужна строгая согалсовонность данных, например, банкосвкие счета. И распределённые системы не подойдут для этого. Также для проектов Green Field эта архитектура позволит быстро развить и понять свой бизнес функционал.

<a name="n-tiered-архитектура"></a>

# N-tiered Architecture

Layered архитектура делит систему на логические слои, тогда как N-tiered архитектура делит её на физические, чаще всего инфраструктурные слои. Один слой может обращаться только к более нижним слоям. Если взять стандартную трёх-уровневую архитектуру, то можно каждый слой разместить на своём физическом. Или же можно на одном физическом разместить несколько логичеких. Каждый физический слой развёртывается на отдельном компьютере. Имеет примерно те же достоинства что и Layered Architecture, при этом улучшенная масштабируемость. Из минусов - появляются задержки когда мы ходим из одного слоя в другой по сети, и также могут возникнуть проблемы с безопасностью при отпарвлении запросов. Используется данная архитектура чаще всего в IaaS прилодениях.

<a name="плагиновая-архитектура"></a>

# Microkernel/Plug-in Architecture

Плагиновая архитектура состоит из двух основных компонентов: ядра и набору независимых друг от друга плагинов. Ядро содержит в себе минимально необходимую функциональность системы. Основную работу и обработку критических функций берёт на себя ядро. Плагины же нужны для улучшения или расширения фцнкциональности. Плюсом является то, что плагины можно изменять независимо друг от друга. В случае выхода из строя плагина остальные комопненты приложения будут работать. Минус заключается в том, что такая система работает медленно из-за сложности обмена сообщениями внутри неё, и при изменении ядра можно нарушить работу плагинов. Так же оджин плагин конфликтовать с другим. Примером являются обычные среды разработки и браузеры.

<a name="событийная-архитектура"></a>

# Event-Driven Architecture

Данная архитектура состоит из producer event и consumer event. Продьсер отправляет события а консьюмер в асинхронном порядке их принимает и обрабатывает. Данная архитекура подходит для множества приложения, как больших так и маленьких. И она часто применяется в микросервисной архитектуре с высоконагруженной системой. Все компоненты очень развязны между собой.  
Есть pub/sub подход, где паблишер отправляет события подписчикам. События отправляются в режиме реального времени и новый подписчик не может прочитать старые события.  
И есть event streaming подход, где события записываются в отдельный журнал, где сохраняются. Консьюмеры могут прочитать этот журнал и получить доступ к любому сообщению.  
Паблишер может вообще не знать, кто именно получает его сообщение. Он просто отправляет событие и не дожидается ответа от кого-либо. Он может находится за логической схемой и быть физическим устройством интернет вещей, например. Есть две разные топологии при реализации такой архитектуры, топология брокера и медиатора.

### Топология брокера

При данной топологии консьюмеры в обычном порядке записывают сообщения в брокер сообщений и нет централизованной обработки этих сообщений. Плюсы в том, что такая система масштабируема, подходит для высоконагруженных систем, и модули развязаны. Минусы в том, что данные могут быть несогласнованными, тяжело контролировать процессы и обрабатывать ошибки при большом количестве таких брокеров.

### Топология медиатора

В этой топологии между компонентами есть посредник, который контролирует инициирование и потравку сообщений при координации нескольких обработчиков событий. Он покрывает недостатки топологии брокера но обладает более низкими масштабируемостью и отказоустойчивостью.

### Практики
1. Error Handling  
Когда консьюмер не может обработать сообщение, то вместо того чтобы блокировать очередь, он делегирует это сообщение workflow processor, который ищёт что не так с сообщением, и в случае устранения проблемы возвращает обратно в очередь. 
2. Preventing Data Loss  
Для того, чтобы избежать потеряю данных, отправитель отправляет сообщение в persistent queue и синхронно дождиается овтета от потребителя что сообщение доставлено. persistent queue сохраняет сообщение на диск. После чего под транзакцией потребитель обрабатывает сообщение
3. Idempotent Consumer  
идемпотентный консьюмер нужен для того, чтобы уметь обрабатывать дублирующиеся сообщения. Например, он может их сохранять в таблицу базы данных по айди сообщения и узнавать, обрабатывал он какое-то сообщение или нет.
4. Transactional messaging
Для того, чтобы данные были консистентные при сохранении данных события в базу данных и отправкой сообщения об этом событии в другой сервис, используется transactional outbox.

<a name="service-based-архитектура"></a>

# Service-Based Architecture

Это распределённая архитектура, в которой есть отедльно развернутые пользовательский интефрейс, крупно-зернисты сервисы и монолитная база данных. Пользовательский интерфейс может быть один для всех сервисов, так и по одному для каждого сервиса. Особенностью архитектуры является то, что есть монолитная база данных, куда ходит совокупность сервисов. Для работы с ней подходят acid транзакции. Такая архитектура не такая дорогая и сложная по сравнению с событийной или миксровервисной. Между интерфейсом и сервисами также может быть API шлюз в виде gateway. Такая архитектура подойтёт в таких ситуациях, когда нам в будущем может подребоваться перейти на микросервисную но на данные момент не нужна такая большая эластичность и масштабируемость.

<a name="space-based-архитектура"></a>

# Space-Based Architecture

Иногда возникают ситуации, когда система должна выдерживать экстремальные нагрузки и отвечать на запросы , и бесконечно масштабировать сервисы и базу данных мы не можем. В таком случае используется Space-Based архитектура. В ней централизованные базы данных заменяются на реплицированную сетку с данными. Такая архитектура скейлится от нагрузки. Минусы заключаются в сложности реализации и большой платы за железо.

<a name="микросервисная-архитектура"></a>

# Microservices Architecture

Микросервсиная архитектура тесно связана с идеологиями Domain Driven Development и bounded conexts. Каждый сервис назависим друг от друга и имеют свою базу данных. При получения запросов от пользователей они сначала попадают в API шлюх, после чего только маршрутизируются к сервисам. Слой API не должен включать в себя никакую бизнес-логику, а занимается, напирмер, аутентификацией и маршрутизацией.  
Есть несколько типов взаимодействия сервисов: хореография и оркестрация. При хореографии каждый сервис работает назависимо и идёт в другие по мере необходимости без централизованного посредника. При оркестрации есть специальный аркестратор рабочего процесса, которые обрабатывает какие-либо сложные и очень важные операции, например банковские, где нужная централизованная обработка событий и ошибок.
Обычно транзакции в базе данных производятся в рамках одного сервиса, но если есть необходимость в распределённых транзакциях, то существует паттерн saga, в котором каждая транзакция выполняется локально, и при ошибке выполняются откатные, компенсирующие транзакции.  
При переиспользовании общего когда есть несколько подходов: библиотека, sidecar, платформа.  
При выделении границ микросервиса, минимальная граница это transaction boundary, а макисмальная это когнитивные возможности команды. Балансированным вариантом считается service per team.
Чтобы определить микросервис, нужна сначала выделить бизнес-возможности системы. Это то, что делает бизнес для создания ценности, например управление заказами отвечает за заказы. У каждой бизнес возможности есть участник, объект, взаимодействия участника с объектом.
Ввписываем все пользовательские сценарии, после чего проводим стрелочки от участника к действию, от действия к объекту. Бизнес возможности характеризуются одними и теми же учатсниками, действиями и объектами. По ним объеденим все элементы на бизнес возможности.  
Далее в зависимости от текущих ограничений и возможностей строим карту контекстов, объеденяя некоторые бизнес-возможности. Для этого мы объединим неинтересные нам бизнес-возможности, удалим всё внутренние связи полученных моделей, выстроим ĸаналы ĸоммуниĸации.
При выделении контекстов в микросервисы нужно уточнить есть ли для этого ресурсы, если есть, то каждый контекст - микросервис.
Микросервисная архитектура в связке с event-driven обладает очень высокимим масштабируемостью, отказоустойчивостью, эластичностью, эволюционностью. Но недостатки в сложности реализации и стоимости содержания. Стоит переходить на эту архиткуру если нет другог выбора и нам нужен короткие time-to-market.
